For our chord implementation, we start with a basic building block of a remote node. A remote node contains its own IP address as well as its hash. This data is stored as a NodeInfo object. Additionally, a remote node contains NodeInfo of its successor and predecessor. 

We have added a few different chord message types to help when sending and receiving chochord packets: REQ_SUC, RSP_SUC, REQ_NOT, REQ_CP, RSP_CP, and RING_DBG. REQ_SUC and RSP_SUC are requests and responses for packets containing successor information, respectively. REQ_NOT is a request for notification. REQ_CP and RSP_CP are requests and responses for chord packets, respectively. RING_DBG contains debug information for ring stabilization. 

To notify the system of updates, we process each chord message by having the remote node reply to its successor node. If the message is of type REQ_NOT, then we compare hashes and update the time when the node's predecessor was last seen. 

For ring stabilization, we've added a few stabilization timers that get started and configured when the overlay is created. The timer goes off every 15 seconds. We have added a stabilization function that sets the timer and debug log. To to see if a node is in range (ie, if the successor is correct), we use a range_compare() function that hashes the addresses to see if they are in the correct range.  To help with stabilization, we do the following: if a REQ_SUC message is seen, check if the successor is in range. If the successor is not in range, then find the actual successor. If the message is a RSP_SUC message, then we compare the range using range_compare() and update the network accordingly. If the message is a RSP_CP message, then we also compare the range. If the node is in range, then we set this node as the predecessor and declare that the ring is stabilized. 

To debug the ring, we have implemented a ring debugging function that sends a RING_DBG message that is called when given the ringstate command. 

In order to facilitate a graceful departure from the ring, we have designed the leaving as a 3 step process. First, the departing node will notify its predecessor with the departing node's successor information. The predecessor set its successor to the new information and will then notify the original successor that it is the new predecessor. The successor will update its information and then notify the departing node. At this point, since both of the departing node's successor and predecessor have updated to the new information, the node will depart the ring.
