For our search functionality, we take the originating IP address, list of keywords we are searching for, and any document results received, and put it all in a struct to keep it together. The keywords and documents are both vectors of strings. This enables easy association on a successful lookup request, as we simply have a map of the chord transaction ID and the struct which gets added at lookup, and then we find on successful lookup, using the struct for the computations.

Since the first step in the search process is to look for the first keyword, the node associated with the first keyword will receive an empty results list. Upon receipt of an empty results list, the node simply takes its list of documents associated with the keyword and puts that into the results. On the other hand, if a node receives a non-empty documents list, it compares its list of documents associated with the first keyword in the current list of keywords to the list of results, keeping those which are a match. Once we do the comparison or add to an empty list, we remove the first keyword from the list. We then check to see if there are additional keywords, or if that was the last keyword. This determines whether we send the result back to the originating node or do a lookup to pass on the partial results to the node responsible for the next (now first) keyword.

In order to facilitate the proper debugging messages, the search process has been split into 3 message types. A SearchInit message is used to send the initial list of keywords and query node to the chord node responsible for initiating the search. If the query node is the responsible node, this message is skipped. All messages that will require a keyword comparison are sent as a SearchRsp message. The final result or an empty list along the way is sent back to the originating node as a SearchFin message.
